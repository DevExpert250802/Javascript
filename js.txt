//  ctrl+/--> comment
// console.log can print something on console
// /* hello world program */
console.log("hello world");
console.log('hello world');
console.log(`hello world`);



"use strict";
// The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
// intro to variables

// variables can store some information
// we can use tha information or change that information later

// declare a variable using 'var' keyword 
 
// firstName -> name of variable
var firstName = "Devansh";

// use a variable
console.log(firstName);

// change value of variable
 firstName = "Smrit";

console.log(firstName);



// rules for making variables 

// you can not start with number
// example :-
// 1value (invalid)
// value1 (invalid)

var value1 = 10;
console.log(value1);
console.log(value1**2);
console.log(value1+10);
console.log(value1-10);
console.log(value1/4);
console.log(value1%6);

// you can use only underscore _ or dollar symbol $
// first_name (valid)
// _firstname (valid)
// first$name (valid)
// $firstname (valid)

// &firstname (invalid)
// first&name (invalid)
// *firstname (invalid)
// %firstname (invalid)

// you cannot use spaces
// first name (invalid)

// var first_name = "Devansh"; // snake case writing
// var firstName = "Devansh"; // camel case writing

// convention not rule
// start with small letter and use camelCase



//  let keyword

// declare variable with let keyword 

// var firstName = "devansh";
// var firstName = "devansh";

let firstName = "devansh";
firstName = "dev"; // (valid)

// let firstName= "dev";(error) (we can declare new variable in case of var using var 2 times but we can not declare new variable with using let 2 times)

console.log(firstName);

// block scope vs function scope



// declare constants
// const key word is used

const pi = 3.14 ;
// pi = 3.15; (invalid)(Uncaught TypeError)
 
console.log(pi);

// use constant 
console.log(pi*2*2);




// string indexing

let firstName = "devansh ";

// d e v a n s h 
// 0 1 2 3 4 5 6 7

console.log(firstName[3]); //( to print letter in string)

// length of string

// firstName.length
console.log(firstName.length); // 7 (print length of string)

// last index :  length-1
console.log(firstName[firstName.length-1]);



// useful string methods

// a) trim()
// b) toUpperCase()
// c) toLowerCase()
// d) slice()
 
// a) :-
let firstName = "   Devansh   ";
// console.log(firstName.length;  13

//  to remove spaces we use trim method

// if we use sting like this it wouuld not work as string is immutable
// firstName.trim(); (it didnit change the existing string it gives us new string) // "devansh"
// console.log(firstName.length); 13

// we can store this new string in another variable or put this string in same variable  
// 1
let newString = firstName.trim();
console.log(newString);
console.log(newString.length);
// 2
 firstName = firstName.trim();
console.log(firstName)
console.log(firstName.length);
 
// b) :-
// convert the letters of string into upper case
// firstName.toUpperCase() (new string)
console.log(firstName.toUpperCase());
 
// we can store this new string 
firstName = firstName.toUpperCase();
console.log(firstName);

//strings areee immutable
// firstName.toUpperCase(); // it will give new string so we have to store that new string
// console.log(firstName);


// c) :-
// converts the letters of string to lower case (similar to b)
firstName = firstName.toLowerCase();
console.log(firstName);

// d) :-

// start index (0)
// end index (end+1)(not include last index)

let mynewString = firstName.slice(0,5); // devan 
console.log(mynewString);

 mynewString = firstName.slice(2,5);  //van
console.log(mynewString);

mynewString = firstName.slice(3);  //ansh
console.log(mynewString);



// typeof operator

// data types (primitive data types)
// string "harshit"
// number 2, 4, 5, 6.7
//  booleans
// undefined
// null
// BigInt
// Symbol

//  typeof operator tells about the which type of  data type it is

let age = 22;
let firstName = "devansh";

console.log(typeof age); //number
console.log(typeof 22); //number
console.log(typeof firstName); // string
console.log(typeof "devansh");//string

// convert number to string

// 22 -> "22"
// 1 method
console.log(typeof (age + "")); //string
//  2 method
age = age + "";
console.log(typeof age); //string
// 3 method
age = String(age);
console.log(typeof age);  // string


// convert string to number.

let myString = "34";
console.log(typeof myString); //string

  // 1 method
let mynewString = +"34";
console.log(typeof myString); //number
// 2 method
 let myStr = "18";
 myStr = Number(myStr)
 console.log(typeof myStr);




// string concatenation

 let string1 = "devansh";
 let string2 = "smrit";
  let fullName = string1 + " " + string2;
  console.log(fullName);


  let string3 = "10";
 let string4 = "20";
  let fullNam = string3  + string4;
  console.log(fullNam);//1710


  let str1 = "10";
 let str2 = "20";
  let myStr = +str1 + +str2;
  console.log(myStr);//30
  console.log(typeof myStr);//number

  

//  template string
let age = 22;
let firstName = "devansh";

//"my name is devansh and my age is 22"
// let aboutMe = "my name is " + firstName + " and my age is " + age;
//  console.log(aboutMe);
 
let aboutMe = `my name is ${firstName} and my age is ${age} `
console.log(aboutMe);




// undefined

let firstName;
console.log(typeof firstName) // undefined comes when you have not assign any value in variable
firstName = "devansh";
console.log(firstName, typeof firstName) // we can print more than 1 values in string

var firstNam;
console.log(typeof firstNam)

// const firstName1;  // error
// console.log(typeof firstName1) 

//null

let myVariable = null;
console.log(myVariable);
myVariable = "devansh";
console.log(myVariable, typeof myVariable);
console.log(typeof null); // object (typeof null -> null)
// (object->refrence datatype) -> bug/error in javascript 

// BigInt

let myNumber = 123;
console.log(myNumber);
console.log(Number.MAX_SAFE_INTEGER);//maximum value you store in js

 let myNum = 123n
 let myNumb = BigInt(123)
 console.log(myNum);
 console.log(myNumb);
 console.log(myNum+myNumb);//135n
// if both number are not BigInt then error will occur " mix BigInt and other types , use explicit conversion"




// booleans & comparision operator

// booleans
//true , false

// comparision operator (<,>,=)
let num1 = 5;
let num2 = 7;
// num1>num2 ( true or false)
console.log(num1>num2);

// ==  vs ====

// ==
let num3 = 7;
let num4 = 7;
let num5 = "7";
let num6 = 7;
console.log(num3 == num4)// true
console.log(num5 == num4) //  true as == check your value not your datatype
// ===
console.log(num5 === num6) // false checks both value and datatype

// !=  vs !===
console.log(num1!=num2);//true
console.log(num3!=num4); //false
console.log(num5!=num6)// false (value is same)
console.log(num5!==num6)// true ( checks both data type and value)




// truthy and falsy values

// falsy values
// false
// ""
// null
// undefined
// 0

// truthy values
// "abc"
// 1, -1



// if else condition

let age = 19 ;

if(age>18){ //true
    console.log(" user can play ddlc");
}

let age1 = 17 ;
if(age1>18){// false
    console.log(" user can play ddlc");
}


let age2 = 17 ;
if(age2>18) //  condition is true
{
    console.log(" user can play ddlc");
}
else // condition is false
{
    console.log("user can not play ddlc")
}

let num = 14;
if(num%2===0){
    console.log("even")
}
else{
    console.log("odd")
}
// falsy values

// false
// ""
// null
// undefined
// 0

let firstName = ""; //empty string is falsy value

if (firstName){
    console.log(firstName);
}
else{
    console.log("first name is  kinda empty")
}

let firstName1 ; //undefined is falsy value

if (firstName1){
    console.log(firstName1);
}
else{
    console.log("first name is  kinda empty")
}

// truthy
// "abc"
//  1,-1
let firstNam =" devansh" 

if (firstNam){
    console.log(firstNam);
}
else{
    console.log("first name is  kinda empty")
}
let firstName2 = 1;

if (firstName2){
    console.log(firstName2);
}
else{
    console.log("first name is  kinda empty")
}




// ternary operator 

let age = 4;
let drink;

if(age>=5){
    drink = "coffee";
}else{
    drink = "milk";
}
console.log(drink);

// ternary operator / conditional operator
// true-> ? , false -> : 
 age = 8;
 drink = age >= 5 ? "coffee" : "milk";
console.log(drink);



// and  or operator 

let firstName = "Harshit";
let age = 22;
if(firstName[0] === "H"){
    console.log("your name starts with H")
}

if(age > 18){
    console.log("you are above 18");
}
// and operator (checks both condition) -> && 

if(firstName[0] === "H" && age>18){
    console.log("Name starts with H and above 18");
}else{
    console.log("inside else");
}

// or operator (checks either condition) -> ||
 firstName = "arshit";
 age = 16;

if(firstName[0] === "H" || age>18){
    console.log("inside if");
}else{
    console.log("inside else");
}


// nested if else
// nesting if & else in else
//game --:
// winning number 19 

// 19 your guess is right 
// 17 too low 
// 20 too high 

// "prompt" function is used to take input in your browser , we can pass massage in it eg: Guess a number 
//+prompt takes input in number (string --> number)
let winningNumber = 19;
let userGuess = +prompt("Guess a number"); // store the value in "userGuess" variable

if(userGuess === winningNumber){
    console.log("Your guess is right!!");
}else{
    if(userGuess < winningNumber){
        console.log("too low !!!");
    }else{
        console.log("too high !!!");
    }
}



// if 
// else if 
// else if 
// else if 
// else 

let tempInDegree = 50;

if(tempInDegree < 0){
    console.log("extremely cold outside");
}else if(tempInDegree < 16){
    console.log("It is cold outside");
}else if(tempInDegree < 25){
    console.log("wheather is okay ");
}else if(tempInDegree < 35){
    console.log("lets go for swim");
}else if(tempInDegree < 45){
    console.log("turn on AC");
}else{
    console.log("too hot!!");
}



  tempInDegree = 4;

if(tempInDegree > 40){
    console.log("too hot");
}else if(tempInDegree > 30){
    console.log("lets go for swim");
}else if(tempInDegree > 20){
    console.log("weather is cool");
}else if(tempInDegree > 10){
    console.log("it is very cold outside");
}else{
    console.log("extremely cold");
}



// switch statement 

// let day = 7; 

// if(day === 0){
//     console.log("Sunday");
// }else if(day ===1){
//     console.log("Monday");
// }else if(day ===2){
//     console.log("Tuesday");
// }else if(day ===3){
//     console.log("Wednesday");
// }else if(day ===4){
//     console.log("Thrusday");
// }else if(day ===5){
//     console.log("Friday");
// }else if(day ===6){
//     console.log("Saturday");
// }else{
//     console.log("Invalid Day");
// }

// "break" is used  to break the switch block
let day = 9;

switch(day){
    case 0:
        console.log("Sunday");
        break;  // to break the switch block
    case 1:
        console.log("Monday");
        break;
    case 2:
        console.log("Tuesday");
        break;
    case 3:
        console.log("Wednesday");
        break;
    case 4:
        console.log("Thrusday");
        break;
    case 5:
        console.log("Friday");
        break;
    case 6:
        console.log("Saturday");
        break;
    default:
        console.log("Invalid Day");
}



// while loop 

// 0 se 9 
// dry principle ->don't repeat yourself
let i = 0; // 1 2 3 4 .......

while(i<=9){
    console.log(i);
    i++;
}
console.log(`current value of i is ${i}`); // template string //current value of i is 10
console.log("hello");




// while loop example 
let num = 100;
let total = 0; //1 + 2 +3
let i = 0;

while(i<=100){
    total = total + i;
    i++;
}
console.log(total);

// sum of n natural numbers -> (n*(n+1))/2
 total = (num*(num+1))/2;
console.log(total);








// intro to for loop 
// print 0 to 9

for(let i = 0;i<=9;i++){
    console.log(i);
}
// console.log("value of i is ",i); //error as i dose not exist out of for block

for(var i = 0;i<=9;i++){
    console.log(i);
}
console.log("value of i is ",i);// i exist outside for loop

//we can use i outside
 let j = 0;
for(;j<=9;j++){
    console.log(j);
}
console.log("value of j is ",j);




// for loop example 

let total = 10;

let num = 100;

for(let i = 0; i<=num; i++){
    total = total + i;
}

console.log(total);




// break keywork
// stops the execution of for loop and execution jumps outside the for block
for(let i = 1; i<=10; i++){
    if(i===4){
        break; 
    }
    console.log(i);
}
console.log("hello there");

// continue keyword 
// using continue current execution will skip 
for(let i = 1; i<=10; i++){
    if(i===4){
        continue;
    }
    console.log(i);
}




// do while loop
// generally used to execute false condition at a time

// let i = 0;
// while(i<=9){
//     console.log(i);
//     i++;
// }

  let i = 10;
do{
    console.log(i);
    i++;
}while(i<=9);
console.log("value of i is ", i)





// intro to arrays 
// reference type (datatype)
// reference type --> object
// how to create arrays

// array are ordered/homogenous collection of items
 // array created using [] brackets


let fruits = ["apple", "mango", "grapes"];
let numbers = [1,2,3,4];
let mixed = [1,2,2.3, "string", null, undefined];
console.log(mixed);
console.log(numbers);
console.log(fruits[2]);

let obj = {}; // object literal
console.log(fruits);
fruits[1] = "banana";// change at first index
console.log(fruits);
console.log(typeof fruits);
console.log(typeof obj);
console.log(Array.isArray(fruits));
console.log(Array.isArray(obj));


// array indexing  





// array push pop 
// array(refrence type) is mutable(original array can be changed)
// while string (primitive type) is immutable
// array shift unshift 

let fruits = ["apple", "mango", "grapes"];
console.log(fruits);

// push --> add last 
fruits.push("banana");
console.log(fruits);

// pop --> remove the last element and return that element....
let poppedFruit = fruits.pop();
console.log(fruits);
console.log("popped fruits is", poppedFruit);

// unshift --> add in start
fruits.unshift("banana");
fruits.unshift("myfruit");
console.log(fruits);

// shift --> remove the starting element and return that element....
let removedFruit = fruits.shift();
console.log(fruits);
console.log("removed fruits is ", removedFruit);
// push and pop are faster as compared to shift and unshift
// as push and pop, adds/removes the element in last and shift and unshift adds/removes the element in starting which shifts every element





//*****primitve vs reference data types******

// /primitve
let num1 = 6;
let num2 = num1;
console.log("value is num1 is", num1);
console.log("value is num2 is", num2);
num1++;
console.log("after incrementing num1")
console.log("value is num1 is", num1);//7
console.log("value is num2 is", num2);//6


// reference types 
// 1 array 

let array1 = ["item1", "item2"];
let array2 = array1;
console.log("array1", array1);
console.log("array2", array2);
array1.push("item3");
console.log("after pushing element to array 1");
console.log("array1", array1);
console.log("array2", array2);

// primitive data type are stored in stack less memory needed
// when we write let num1 = 4 it is stored somewhere in stack, let num2 = num1 it is stores somewhere in stack(memory) 
// if num1++ there is no change in num2 as both element are different in stack

// refrence data types are stored in heap which has whose address stored in stack
// let array1 = ["item1","item2"]; array2 = array1; (array1 and array2 has same address when stored in stack ) 
// in stack a pointer1 is present which has the address of array 1 any change in array 1 led the change in array2
// array1.push("item3") then we go to stack --> pointer of array1 which has the address of array1 which is stored in heap and when we push item3
// change in heap will reflect in both array1 and array2 as both elements has same address



// how to clone array 
// how to concatenate two arrays

// let array1 = ["item1", "item2"];
// let array2 = array1;
// console.log(array1===array2);


// task 1 :- we have to make array2 in such a way that
//  if we change anything in array1 nothing will be changed in array2


// let array2 = ["item1", "item2"]; //method 0 (it is not good if we have 1000 elements)

// let array2 = array1.slice(0);     //method 1 (0 to last index)(faster)

// let array2 = [].concat(array1);   //method 2 (adding empty array in array1)

// spread operator
//  let array2 = [...array1];        //method3

// array1.push("item3");

// console.log(array1===array2);//to check whether both array are same or not
// console.log(array1)
// console.log(array2)

// task 2 :-
// clone array 1 and add items in 2nd array

// let array2 = array1.slice(0).concat(["item3", "item4"]);
// let array2 = [].concat(array1,["item3", "item4"]);
// new way 
// spread operator
// let oneMoreArray = ["item3", "item4"]
//  array2 = [...array1, ...oneMoreArray];

// array1.push("item3");

// console.log(array1===array2);//to check whether both array are same or not
// console.log(array1)
// console.log(array2)



// for loop in array 

let fruits = ["apple", "mango", "grapes", "banana"];

for(let i=0; i<=9;i++){
    console.log(i);
}
console.log(fruits.length);
console.log(fruits[fruits.length-2]); // last second index
let fruits2 = [];
for(let i=0; i < fruits.length; i++){
    fruits2.push(fruits[i].toUpperCase());
}

console.log(fruits2);



// use const for creating Array or any refrence types (as used by 90% developers)

// const pi = 3.14;
// pi = 4.7  (error as const can not be re-defined)
// array stored in heap memory fruits = ["apples","mango"]; // 0x11
const fruits = ["apples","mango"]; // 0x11
// fruits=["grapes","pineapple"] (error)
fruits.push("banana");
console.log(fruits);




// while loop in array 
const fruits = ["apple", "mango", "grapes"];
const fruits2 = [];
let i = 0;
while(i<fruits.length){
    fruits2.push(fruits[i].toUpperCase());
    i++;
}
console.log(fruits2);





// for of loop in array
// used for iteration of normal array

// new way to iterate loop
// internally works as for loop, it works automatically it iterates till its length as you increase the length of array it automatically increases
// const fruits = [ "apples","mango","grapes","fruit4","fruit5"];

// for(let fruit of fruits){
//     console.log(fruit);
// }
//  we can also write ( but it is tough for understanding)
// const i = [ "apples","mango","grapes","fruit4","fruit5"];
// for(let k of i){  
//     console.log(k);
// }
const fruits = [ "apples","mango","grapes","fruit4","fruit5"];
fruits2 = [];

for(let fruit of fruits){
    fruits2.push(fruit.toUpperCase());
}
    console.log(fruits2);
    



// for in loop in array
// used very less

// const fruits = ["apple", "mango", "grapes", "fruit4", "fruit5"];

// for(let index in fruits){
    // console.log(index); // prints index
// }

// for(let index in fruits){
    // console.log(fruits[index]); // prints items on that index
// }

// }
const fruits = ["apple", "mango", "grapes", "fruit4", "fruit5"];
const fruits2 = [];

for(let index in fruits){
    fruits2.push(fruits[index].toUpperCase());
}
console.log(fruits2);





// array destructuring

const myArray = ["value1","value2","value3"];
//  task-: create 2 variables in which stores value1 on 1st variable and value2 on 2nd variable
// method 1
// let myvar1 = myArray[0];
// let myvar2 = myArray[1];
// console.log("value of myvar1" , myvar1);
// console.log("value of myvar2" , myvar2);
// method 2

 let[myvar1,myvar2,myvar3] = myArray; // if i use const instead of let then we cannot change the value

 // myvar1 = "value changed" // to change the value

 console.log("value of myvar1" , myvar1);
console.log("value of myvar2" , myvar2);
console.log("value of myvar3" , myvar3);

// case1 -:
// const myArray = ["value1"];
// let[myvar1,myvar2,myvar3] = myArray; 
// console.log("value of myvar1" , myvar1);
// console.log("value of myvar2" , myvar2);//undefined
// console.log("value of myvar3" , myvar3);//undefined

// case2 -:
// const myArray = ["value1" , "value2", "value3"];
// let[myvar1,myvar2] = myArray; 
// console.log("value of myvar1" , myvar1);
// console.log("value of myvar2" , myvar2);

// case3 -: //index skiping
// const myArray = ["value1" , "value2", "value3"];
// let[myvar1, ,myvar2] = myArray; 
// console.log("value of myvar1" , myvar1);
// console.log("value of myvar2" , myvar2);  //value3

// case4 -: storing value 1 and 2 in myvar1 and myvar2 and 3 and 4 in another array
// const myArray = ["value1" , "value2", "value3", "value4"];

// method 1:-
// let[myvar1,myvar2] = myArray; 
// let mynewarray = myArray.slice(2) // not to be used

//method 2:-

// let[myvar1,myvar2,...myNewArray] = myArray; 


// console.log("value of myvar1" , myvar1);
// console.log("value of myvar2" , myvar2);






// objects (reference type)  

// arrays are good but not sufficient 
// for real world data 

// objects store key value pairs 
// objects don't have index

// how to create objects 
// object--> const; object name --> person; object-->{} ;key/ prpoerties-->name,age ; value-->(string) harstit,22
// const person = {name:"Harshit",age:22};
// console.log(typeof person); // object

const person = {
    name: "harshit",
    age: 22,
    hobbies: ["guitar", "sleeping", "listening music"]
}
console.log(person);

// how to access data from objects (dot notation and bracket notation)
// console.log(person.name); 
// console.log(person.age); 
// console.log(person["name"]); // key in js is bydefault in string "" or''
// console.log(person["age"]);
// console.log(person.hobbies);

// how to add key value pair to objects (dot notation and bracket notation)
// person.gender = "male";
person["gender"] = "male";
console.log(person);




// difference between dot and bracket Notation

// const key = "email";
// const person = {
//     name: "harshit",
//     age: 22,
//     "person hobbies": ["guitar", "sleeping", "listening music"] ( key with more than 2 word) )

// }
// console.log(person.person hobbies);// error due to space
// console.log(person["person hobbies"]);

//// person.key = "harshitvashisth@gmail.com"; // key hee key ban gayi

// person[key] = "harshitvashisth@gmail.com";// key is email
// console.log(person); 



// how to iterate object

const person = {
    name: "harshit",
    age: 22,
    "person hobbies": ["guitar", "sleeping", "listening music"]
}
 
// to iterate objects we use 2 methods:-

// for in loop 
// Object.keys

// method 1 -> for in loop -:

// to print key:-
for(let key in person ){
    console.log(key);  
}
//  to print value pairs :-

// for(let key in person ){
//     console.log(person.key);   // undefined as there is no key->name in person 
// }

for(let key in person ){
    console.log(person[key]);  
}

//  to print key value pairs :-

for(let key in person ){
    // console.log(`${key} : ${person[key]}`);  
    console.log(key, " :",person[key]);
}

//method 2 -> Object.keys

console.log(Object.keys(person)) //keys  return array
console.log(typeof (Object.keys(person))) // to check type (object)
const val = Array.isArray(Object.keys(person)) // to check it is array or not...
console.log(val);
for(let key of Object.keys(person)){
    console.log(keys); //keys
    console.log(person[key]); //value
}


// computed properties

const key1 = "objkey1";
const key2 = "objkey2";

const value1 = "myvalue1";
const value2 = "myvalue2";

// task:-
// const obj = {
//     objkey1 : "myvalue1",
//     objkey2 : "myvalue2",
// }


// const obj = {
//   key1 : value1   //  output: {key1 : "myvalue1",key2 : "myvalue2" }
//   key2 : value2
// }
// console.log(obj);


// const obj = {
//   [key1] : value1, 
//   [key2]: value2
// }
// console.log(obj);

const obj = {};

obj[key1] = value1;
obj[key2] = value2;
console.log(obj); 



// spread operator
// const array1 = [1, 2, 3];
// const array2 = [5, 6, 7];

// working of spread operator

// const newArray = [...array1, ...array2] // merge of both arrays will come

// const newArray = [...array1, array2] // whole array2 comes as 4th element  orr array2 will not spread

// // const newArray = [...array1, ...array2, 89, 69]; 
// const newArray = [..."123456789"];  // string use is compulsary as it will not iterate and  "not __  iterable error will come" string->iterable
// console.log(newArray);


// spread operator in objects

// same key will not repeat in object
//const obj1 = {
//     key1: "value1",
//     key2: "value2",
//    key1: "value59",

//   };

const obj1 = {
    key1: "value1",
    key2: "value2",
  };
  const obj2 = {
    key1: "valueUnique",
    key3: "value3",
    key4: "value4",
  };
//   const newObject = { ...obj1, ...obj2}; as key1 comes 2 times in obj1 and obj2 both soo key1 of obj2 will come as it is written in last
  // const newObject = { ...obj2, ...obj1, key69: "value69" }; // adding new key

  // const newObject = { ...["item1", "item2"] };

  // const newObject = { ..."abcdefghijklmnopqrstuvwxyz" }; // key value pair (spreading string)
  // console.log(newObject);



// object destructuring

const band = {
  bandName: "led zepplin",
  famousSong: "stairway to heaven",
  year: 1968,
  anotherFamousSong: "kashmir",
};

// const bandName = band.bandName
// const famousSong = band.famousSong
// console.log(bandName,famousSong);
//// bandName = "queen"; // error use of const


let { bandName, famousSong, ...restProps } = band;
console.log(bandName);
console.log(restProps);




// objects inside array 
// very useful in real world applications

const users = [
    {userId: 1,firstName: 'harshit', gender: 'male'},
    {userId: 2,firstName: 'mohit', gender: 'male'},
    {userId: 3,firstName: 'nitish', gender: 'male'},
]
// console.log(user);//  1 array--> 3 objects
for(let user of users){ // 3 different in 3 different lines
    console.log(user);
}

for(let user of users) // only first name.... 
{
    console.log(user.firstName);
}





// nested destructuring 
const users = [
    {userId: 1,firstName: 'harshit', gender: 'male'},
    {userId: 2,firstName: 'mohit', gender: 'male'},
    {userId: 3,firstName: 'nitish', gender: 'male'},
]

// const [user1 , user2 ,user3] = users ; 
// console.log(user1); // print complete object

// destructure from object --> {}
// firstName: user1firstName (change the name)

// const [{firstName: user1firstName, userId}, , {gender: user3gender}] = users;
// console.log(user1firstName);
// console.log(userId);
// console.log(user3gender) 









// function
// function --> keyword 

// example1:-

// singHappyBirthday()->functionname  
function singHappyBirthday(){
    console.log("happy birthday to you ......");
}
// // Function call 
singHappyBirthday();
singHappyBirthday();

// example 2 :-

// function twoPlusFour(){
//     console.log(2+4); 
// }
// // function call  // print the function
// twoPlusFour();  
// twoPlusFour(); 
// twoPlusFour();  

// function twoPlusFour(){
//    return(2+4); // returning the value which can be stored or printed
// }
// console.log(twoPlusFour()); //print
// const returnedValue = twoPlusFour(); // store;
// console.log(returnedValue);

// example 3:-
// Reusable function 
function sumThreeNumbers(number1, number2, number3) // parameter in function
{
    return number1 + number2 + number3;
}
const returnedValue = sumThreeNumbers(2,5,6); // argument-> value we pass to the parameter
console.log(returnedValue);

// example 4:-

// isEven
// input : one number 
// output : true , false 

// method 1
function isEven(number){
    if(number % 2 === 0){
        return true;
    }
    return false;
}
console.log(isEven(4));

// method 2 
function isEven(number){
    return number % 2 === 0;
}
console.log(isEven(4));

// example 5:-
// function 
// input : string 
// output: firstCharacter 

function firstChar(anyString){
    return anyString[0];
}
console.log(firstChar("zbc"));

// example 6:-
// function 
// input : array, target (number)
// output: index of target if target present in array 
// linear search 

function findTarget(array, target){
    for(let i = 0; i<array.length; i++){
        if(array[i]===target){
            return i;
        }
    }
    return -1;
}
const myArray = [1,3,8,90]
const ans = findTarget(myArray, 4);
console.log(ans);







// function expression


// function singHappyBirthday(){
//     console.log("happy birthday to you ......");
// } // function declaration

// function expression
const singHappyBirthday = function(){
    console.log("happy birthday to you ......");
}
singHappyBirthday();

const sumThreeNumbers = function(number1, number2, number3){
    return number1 + number2 + number3;
}
const ans = sumThreeNumbers(2,3,4);
console.log(ans);


// function isEven(number){
//     return number % 2 === 0;
// }
const isEven = function(number){
    return number % 2 === 0;
}
console.log(isEven(2));

const firstChar = function(anyString){
    return anyString[0];
}

const findTarget = function(array, target){
    for(let i = 0; i<array.length; i++){
        if(array[i]===target){
            return i;
        }
    }
    return -1;
}






// arrow functions


// function singHappyBirthday(){
//     console.log("happy birthday to you ......");
// } // function declaration


// const singHappyBirthday = function(){
//     cosole.log("happy birthday to you ......");n
// }// function expression


// arrow functions

const singHappyBirthday = () => {
    console.log("happy birthday to you ......");
}
singHappyBirthday();


const sumThreeNumbers = (number1, number2, number3) => {
    return number1 + number2 + number3;
}
const ans = sumThreeNumbers(2,3,4);
console.log(ans);


// const isEven = function(number) // function expression
// {
//     return number % 2 === 0;
// }

// const isEven = (number) => // arrow function
// {
//     return number % 2 === 0;
// }

//if you have only single parameter you can remove parenthesis ()

// const isEven = number =>
// {
//     return number % 2 === 0;
// }

const isEven = number =>  number % 2 === 0;
    
console.log(isEven(4));


// const firstChar = (anyString) => {
//     return anyString[0];
// }

const firstChar = anyString => anyString[0];

console.log(firstChar("harshit"));


const findTarget = (array, target) => {
    for(let i = 0; i<array.length; i++){
        if(array[i]===target){
            return i;
        }
    }
    return -1;
}



// hoisting 

hello(); // calling before declaring this behaviour is called hosting

function hello(){
    console.log("hello world");
}
// const hello = function() // error in case of function expression : "cannot access 'hello' before initialization"
// {
//     console.log("hello world");
// }

console.log(hello);// error
const hello = "hello world";   
console.log(hello);

console.log(hello);    //undefined
var hello = "hello world"; 
console.log(hello); //hello world







// functions inside function

// arrow function
// const app = () =>{
//     const myFunction =() => {
//         console.log("hello from my function")
//     }
//     console.log("inside app")
//     myFunction();
// }
// app();

// function declaration :-
function app(){
    const myFunc = () =>{
        console.log("hello from myFunc")
    }

    const addTwo = (num1, num2) =>{
        return num1 + num2;
    }

    const mul = (num1, num2) => num1* num2;

    console.log("inside app");
    myFunc();
    console.log(addTwo(2,3));
    console.log(mul(2,3));
}
app();






// lexical scope 

const myVar = "value1";//** lexical scope of global variable

function myApp(){

    // const myVar = "value1"; 

    function myFunc(){
        // const myVar = "value59";
        const myFunc2 = () =>{
            console.log("inside myFunc", myVar);//** see if myVar is present then check lexical scope of myfunc-> myApp
        }
        myFunc2();//call 3
    }


    console.log(myVar);//** see if myVar is present then checks lexical scope of myApp
    myFunc();//call 2
}

myApp();// call 1








// block scope vs function scope 
// { } => matter present in curly braces is called block

// let and const are block scope
// var is function scope

// {    
//     block 1 
//  }

// {  
//   block 2
//  }

// {
//     let firstName = "harshit"; 
// }
// console.log(firstName); // error :as let is block scope.

// different block different variable
{
    let firstName = "harshit"; 
    console.log(firstName);
}// let is block scope

{
   const firstName = "mohit"; 
    console.log(firstName);
}// let and const are block scope

    const firstName = "Dev"; 
console.log(firstName)
// let and const are block(block of global block) scope


{
   var firstname = "smriti"; 
}
 console.log(firstname);// var is function scope

if(true){
    var firstNamme = "harshita";
    console.log(firstName);
}
console.log(firstNamme);


// if(true){
//     let firstName = "harshit";
//     console.log(firstName);
// }
// console.log(firstName); // error : let is block scope


// function myApp(){
//     if(true){
//        let firstName = "harshit";
//         console.log(firstName);
//     }
////     console.log(firstName); // error : let is block scope
//  }
//   myApp();

function myApp(){
    if(true){
        var firstName = "harshiti"; // var can be used inside the function in any block
        console.log(firstName);
    }

    if(true){
        console.log(firstName);
    }
    console.log(firstName);
}

myApp();






// default parameters 

// // before ES2015 

// function addTwo(a,b){
//     if(typeof b ==="undefined"){
//         b = 1;
//     }
//     return a+b;
// }
// const ans = addTwo(4);
// console.log(ans)



function addTwo(a,b=0){
    return a+b;
}

const ans = addTwo(4, 8);
console.log(ans)





// rest parameters 


// function myFunc(a,b,c){
//     console.log(`a is ${a}`);
//     console.log(`b is ${b}`);
//     console.log(`c is ${c}`);
// }
// myFunc(3,4,5);


function myFunc(a,b,...c){
    console.log(`a is ${a}`);
    console.log(`b is ${b}`);
    console.log(`c is ${c}`); // string template
    console.log(`c is` , c);  //array
}

myFunc(3,4,5,6,7,8,9);

function addAll(...numbers){
    let total = 0;
    for(let number of numbers){
        total = total + number;
    }
    return total;
}

const ans = addAll(4,5,4,66,10);
console.log(ans);





// parameter destructuring 
  

// object 
// react 

const person = {
    firstName: "harshit",
    gender: "male",  
    age: 500
}

// function printDetails(obj){
//     console.log(obj.firstName);
//     console.log(obj.gender);
//  console.log(obj.gender);
// }

function printDetails({firstName, gender, age}){
    console.log(firstName);
    console.log(gender);
    console.log(age);
}

printDetails(person);







// callback functions 
// function taken as input and called
// (higher order function)

function myFunc2(name){
    console.log("inside my func 2")
    console.log(`your name is ${name}`);
}


function myFunc(callback){
    console.log("hello there I am a func and I can..")
    callback("harshit");
}

myFunc(myFunc2);


// output:--

// hello there I am a func and I can..
// inside my func 2
// your name is harshit




// function returning function 
// (higher order function)

// function myFunc(){
//     function hello(){
//        console.log("hello world")
//     }
//     return hello;     //return
// }
// const ans = myFunc();  //store
// console.log(ans)       //print
// ans()                  //call


function myFunc(){
    function hello(){
        return "hello world"
    }
    return hello;  // return hello function
}

const ans = myFunc(); // store hello function
console.log(ans());


// function myFunc(){
//     return Function(){
//         return "hello world"
//     }
//     
// }
// const ans = myFunc(); 
// console.log(ans());







// important array methods 


// forEach
// map
// filter
// reduce


const numbers = [4,2,5,8];


// example 1 -:

// function multiplyBy2(number , index){
//     console.log(" index is ", index);
//     console.log(`${number}*2 = ${number*2}`);
// }
// for(let i = 0; i < numbers.length ; i++){
//     multiplyBy2(numbers[i],i);
// }

// example 2(a) -:
// function myFunc(number, index){
//     console.log(`index is ${index} number is ${number}`);
// }

//method1 -:

// for(let i = 0; i < numbers.length ; i++){
//     myFunc(numbers[i],i);
// }

// method2-:
 // input -> callback method 
// 1-> number present in array 
//2-> index of array

//     numbers.forEach(myfunc);


// example 2(b) -:
// numbers.forEach(function(number,index) 
// {
//     console.log(`index is ${index} number is ${number}`);
// });


// example3:- 
// numbers.forEach(function(number, index){
//     console.log(number*3, index);
// })


//realistic example :- 
const users = [
    {firstName: "harshit", age: 23},
    {firstName: "mohit", age: 21},
    {firstName: "nitish", age: 22},
    {firstName: "garima", age: 20},
]

// users.forEach(function(user){
//     console.log(user.firstName);
// });

// for(let user of users){
//     console.log(user.firstName);
// }

// users.forEach((user) =>{
//     console.log(user.firstName);
// })

// users.forEach( user =>{
//     console.log(user.firstName);
// })

// users.forEach((user, index)=>{
//     console.log(user.firstName, index);
// })





// map method (**important)

// **works same as foreach take callback as input
// ** map function-> returns new Array
// ** return in map is necessary as nothing returns then by default  "undefined"   return (if you use console.log directly instead return)


const numbers = [3,4,6,1,8];

// //  method 1
// const square = function(number){
//     return number*number;
// }
// // numbers.map(square); //  square -> function name and map -> creates new array 

// const squareNumber = numbers.map(square); //squareNumber stores new array 
// console.log(squareNumber);

// method 2 {inside map function}
// const squareNumber = numbers.map(function(number){
//     return number * number ;
// });
// console.log(squareNumber);


// method 3 {arrow function}
// const squareNumber = numbers.map(number=>{
//     return number * number ;
// });
// console.log(squareNumber);

// // const squareNumber = numbers.map((number, index)=>{
//   return  `index: ${index},${number*number} ` ;
// });
// console.log(squareNumber);

////realistic example :-

// const users = [
//     {firstName: "harshit", age: 23},
//     {firstName: "mohit", age: 21},
//     {firstName: "nitish", age: 22},
//     {firstName: "garima", age: 20},
// ]

// const userNames = users.map((user)=>{
//     return user.firstName;
// });

// console.log(userNames);





// filter method 

 const numbers = [1,3,2,6,4,8,9];

//  numbers.filter(); input ->callback function (return boolean value ) 

//method 1 

// const isEven = function(number)// function expression
//  {
//     return number % 2 === 0;
// }
// const evenNumbers = numbers.filter(isEven);
// console.log(evenNumbers);


// const isOdd = function(number) // function expression
//  {
//     return number % 2 !== 0;
// }
// const OddNumbers = numbers.filter(isOdd);
// console.log(OddNumbers);


//method 2

const evenNumbers = numbers.filter((number)=>{
    return number % 2 === 0;
});
console.log(evenNumbers)



// reduce 

// numbers.reduce((() =>{}); -> use , input -> callback function

const numbers = [1,2,3,4,5, 10];

// aim : sum of all the numbers in array 

const sum = numbers.reduce((accumulator, currentValue)=>{
    return accumulator + currentValue;
}, 100); // 100-->>  passing initial value

console.log(sum);

//   Trace :-
// accumulator , currentValue,  return 
// 1               2              3     (first function) 
// 3(return)       3              6
// 6               4              10
// 10              5              15
// 15              10             25


// real  life example :-

const userCart = [
    {productId: 1, productName: "mobile", price: 12000},
    {productId: 2, productName: "laptop", price: 22000},
    {productId: 3, productName: "tv", price: 15000},
]


// Method:1

// let totalPrice = 0;
// for (let i = 0; i < userCart.length; i++) {
//     totalPrice += userCart[i].price;
//   }
// console.log(totalPrice);


// Method:2

let totalPrice = 0;
for (const item of userCart) {
    totalPrice += item.price;
}
console.log(totalPrice);



// Method:3

// const totalPrice = userCart.reduce((accumulator, product) => accumulator + product.price, 0);
// console.log(totalPrice); // Output: 49000


// Method:4

// const totalAmount = userCart.reduce((totalPrice, currentProduct)=>
//    totalPrice + currentProduct.price
// , 0)
// console.log(totalAmount);




// total price      currentValue     return 
// 0                {}                  12000
// 12000            22000                34000
// 34000            15000                49000





// sort method 
// ASCII TABLE 
//char : ascii value


// '0' : 48
// '1' : 49
// '2' : 50
// '3' : 51
// '4' : 52
// '5' : 53
// '6' : 54
// '7' : 55
// '8' : 56
// '9' : 57


// ':' : 58
// ';' : 59
// '<' : 60
// '=' : 61
// '>' : 62
// '?' : 63
// '@' : 64


// 'A' : 65
// 'B' : 66
// 'C' : 67
// 'D' : 68
// 'E' : 69
// 'F' : 70
// 'G' : 71
// 'H' : 72
// 'I' : 73
// 'J' : 74
// 'K' : 75
// 'L' : 76
// 'M' : 77
// 'N' : 78
// 'O' : 79
// 'P' : 80
// 'Q' : 81
// 'R' : 82
// 'S' : 83
// 'T' : 84
// 'U' : 85
// 'V' : 86
// 'W' : 87
// 'X' : 88
// 'Y' : 89
// 'Z' : 90



// '[' : 91
// '\' : 92
// ']' : 93
// '^' : 94
// '_' : 95
// '`' : 96



// 'a' : 97
// 'b' : 98
// 'c' : 99
// 'd' : 100
// 'e' : 101
// 'f' : 102
// 'g' : 103
// 'h' : 104
// 'i' : 105
// 'j' : 106
// 'k' : 107
// 'l' : 108
// 'm' : 109
// 'n' : 110
// 'o' : 111
// 'p' : 112
// 'q' : 113
// 'r' : 114
// 's' : 115
// 't' : 116
// 'u' : 117
// 'v' : 118
// 'w' : 119
// 'x' : 120
// 'y' : 121
// 'z' : 122
// '{' : 123
// '|' : 124
// '}' : 125


// sort  

// example 1
// 5,9,1200, 400, 3000
// 5, 9, 400, 1200, 3000 (expected)

const numbers = [5,9,1200,400,3000];
numbers.sort();
console.log(numbers);

// {1200,3000,400,5,9}  {real answer: javascript is sorting this array as string not a number}

// ["5", "9", "1210", "410", "3000"] -> string
// [53 , 57 ,  49   ,  52  ,  51] -> ascii vaue


////example 2
// const userNames = ['harshit', 'abcd', 'mohit', 'nitish', 'aabc', 'ABC', 'Harshit'];
// userNames.sort();
// console.log(userNames);


// example 3
// const numbers = [5,9,1200, 410, 3000];
// numbers.sort((a,b)=>{
//     return a-b; //  accending order and b-a descending order
// });

//  numbers.sort((a,b)=> a-b);

// console.log(numbers);


//method 2
// numbers.sort((a,b)=>a-b);
// console.log(numbers);


// 1200,410 
// a-b ---> 790
// a-b ---> postive (greater than 0) ---> b, a
// 410 , 1200

// a-b ---> negative ----> a,b
// 5, 9 ---> -4 

// realistic example:-

// price lowToHigh HighToLow 

const products = [
    {productId: 1, produceName: "p1",price: 300 },
    {productId: 2, produceName: "p2",price: 3000 },
    {productId: 3, produceName: "p3",price: 200 },
    {productId: 4, produceName: "p4",price: 8000 },
    {productId: 5, produceName: "p5",price: 500 },
]

// lowToHigh

 products.sort((a,b)=>{
    return a.price-b.price
});
console.log(products);


const lowToHigh = products.slice(0).sort((a,b)=>{
    return a.price-b.price
});
console.log(lowToHigh);

// const highToLow = products.slice(0).sort((a,b)=>{
//     return b.price-a.price;
// });



const users = [
    {firstName: "harshit", age: 23},
    {firstName: "mohit", age: 21},
    {firstName: "nitish", age: 22},
    {firstName: "garima", age: 20},
]


users.sort((a,b)=>{
    if(a.firstName > b.firstName){
        return 1;
    }else{
        return -1;
    }
});

console.log(users);







// find method

// const myArrary = ["Hello", "cat", "dog","lion" ];

// example 1
// function isLength(string){
//     return string.length === 3;
// }
 //  myArray.find()

//  const ans = isLength("doog");
// console.log(ans);

// const ans = myArrary.find(isLength);
// console.log(ans);
 
// example 2
// const ans = myArrary.find((string)=>string.length===3);
// console.log(ans);
  
const users = [
    {userID : 1, userName: "harshit"},
    {userID : 2, userName: "devansh"},
    {userID : 3, userName: "asdrfgg"},
    {userID : 4, userName: "efefbbb"},
    {userID : 5, userName: "harshig"},
]; 

const myUser = users.find((user)=>{
    return user.userID===3
});

// const myUser = users.find((user)=>user.userID===3);
console.log(myUser);




 // every method


// const numbers = [2,4,6,9,10];
// const ans = numbers.every((number)=>number%2===0);
// console.log(ans);

// callback function --> true / false(boolean)
// every method ---> true/ false(boolean) (It gives true only if all elements are even )

const userCart = [
    {productId: 1, productName: "mobile", price: 12000},
    {productId: 2, productName: "laptop", price: 22000},
    {productId: 3, productName: "tv", price: 35000},
]

const ans = userCart.every((cartItem)=>cartItem.price < 30000);
console.log(ans);





// some method 

const numbers = [3,5,11,9];

// kya ek bhi number esa hai jo even hai 
// true 

// const ans = numbers.some((number)=>number%2===0);
// console.log(ans);

const userCart = [
    {productId: 1, productName: "mobile", price: 12000},
    {productId: 2, productName: "laptop", price: 22000},
    {productId: 3, productName: "tv", price: 35000},
    {productId: 3, productName: "macbook", price: 25000},
]

const ans = userCart.some((cartItem)=>cartItem.price > 100000);
console.log(ans);



// fill method 
// value , start , end 

// const myArray = new Array(10).fill(0);
// console.log(myArray);

const myArray = [1,2,3,4,5,6,7,8];
myArray.fill(0,2,5);
console.log(myArray);



// splice method 
// start , delete , insert 

const myArray = ['item1', 'item2', 'item3'];

// delete (it also gives you written of what you deleated)

 //myArray.splice(1,1)
// const deletedItem = myArray.splice(1, 1);
// console.log("delted item", deletedItem);

// insert 
// myArray.splice(1, 0,'inserted item');

// insert and delete simultaneously

const deletedItem = myArray.splice(1, 2, "inserted item1", "inserted item2")
console.log("delted item", deletedItem);
console.log(myArray);





// iterables 
// jispe hum for of loop laga sakein
// string , array are iterable 

const firstName = "Harshit";
for(let char of firstName){
    console.log(char);
}

const items = ['item1', 'item2', 'item3']; 
for(let item of items){
    console.log(item);
}

 // error as objects are not iterables 
// const users = {'key1' : 'value1' , 'key2' : 'value2', 'key3': 'value3'}; 
// for(let item of users){
//     console.log(item);
//}


// array like object 
// jinke pas length property hoti hai 
// aur jiko hum index se access kar sakte hai
// example :- string 


// const firstName = "harshit";
// console.log(firstName.length);
// console.log(firstName[2]);





// Sets (it is iterable)

// jispe hum for of loop laga sakein
// store data  
// sets also have its own methods
// No index-based access 
// Order is not guaranteed
//*** unique items only (no duplicates allowed)

// const numbers = [1,2,3]; // array

// const numbers = new Set(1,2,3); // set
// console.log(numbers);  //Order is not guaranteed (2,1,3 or 1,2,3 or 3,2,1)
// console.log(numbers[2]); // error (undefined)


// const items = ['item1', 'item2', 'item3'];
// const numbers = new Set(); //  empty set
// numbers.add(1);
// numbers.add(2);
// numbers.add(3);
// numbers.add(4);
// numbers.add(5);
// numbers.add(6);
// numbers.add(items);
// numbers.add(items);   //(no duplicates allowed)
//  numbers.add(['item1', 'item2']);
//  numbers.add(['item1', 'item2']); // they will add as they store as different  array in memory(different address)
// if(numbers.has(1)){
//     console.log("1 is present")
// }else{
//     console.log("1 is not present")
// }
// for(let number of numbers){
//     console.log(number);
// }


const myArray = [1,2,4,4,5,6,5,6];
const uniqueElements = new Set(myArray);
let length = 0;
for(let element of uniqueElements){
    length++;
}

console.log(length);










// Maps 
// map is an iterable

// store data in ordered fashion

// store key value pair (like object)
// duplicate keys are not allowed like objects

// Map-> method => get method
// different between maps and objects
//*** objects can only have string or symbol as key 

// in maps you can use anything as key like array, number, string  

// we can use for of loop in maps which we can not use in objects(we can use for in loop in objects)

// object literal 
// key -> string 
// key -> symbol

// const person = {
//     firstName : "harshit",
//     age: 7,
//     1:"one"
// }
// // console.log(person.firstName);
// // console.log(person["firstName"]);
// // console.log(person[1]);
// for(let key in person){ 
//     console.log(typeof key);
// }

// key value pair 

// const person = new Map();  // create map
// person.set('firstName', 'Harshit');
// person.set('age', 7);
// person.set(1,'one');
// person.set([1,2,3],'onetwothree'); //array ->object
// person.set({1: 'one'},'onetwothree');
// console.log(person);
// console.log(person.get(1));
// console.log(person.get(firstName));
// console.log(person.get(age));
// console.log(person.keys()); // map iterator -> print keys using loops
// for(let key of person.keys())
// {
//     console.log(key);
//     console.log(key, typeof key);
// }
// for(let key of person) //key value pair
// {
//   console.log(key); 
//   console.log(Array.isArray(key));
// }
// for(let [key, value] of person)// destructure array
// {
//     console.log(key, value)
// }

// const person = new Map([['firstName','harshit'],['age',7]])
// console.log(person);

// realistic example
const person1 = {
    id: 1,
    firstName: "harshit"
}
const person2 = {
    id: 2,
    firstName: "harshta"
}

const extraInfo = new Map();
extraInfo.set(person1, {age: 8, gender: "male"});
extraInfo.set(person2, {age: 9, gender: "female"});
// console.log(userInfo);
console.log(person1.id);
console.log(extraInfo.get(person1).gender);
console.log(extraInfo.get(person2).gender);





// clone using Object.assign 

//  heap memory  

const obj = {
    key1: "value1",
    key2: "value2"
}
//// const obj2 = {...obj};
//// const obj2 = Object.assign({}, obj);

// const obj2 = {'key69': "value69",...obj};
// const obj2 = Object.assign({'key69': "value69"}, obj);


// obj.key3 = "value3";
// console.log(obj);
// console.log(obj2);





// optional chaining 

const user  = {
    firstName: "harshit",
    address: {houseNumber: '1234'}
}

// console.log(user.firstName);
// console.log(user.address);
// console.log(user.address.houseNumber);

// currently key is absent but in next second the property will appear
// so it dose not give error while accessing undefined

console.log(user?.firstName);
console.log(user?.address?.houseNumber);




// methods
// function inside object
// this-> Object

//// majour problem with this is if you change first name and age you need to directly change in about also which is not possible in this case
// const person = {
//     firstName : "harsh",
//     age: 8,
//     about: function(){
//         console.log("person name is harshit and person age is 8");
//     }
// }
// person.about(); // call


// const person = {
//     firstName : "harsh",
//     age: 8,
//     about: function(){
//         console.log("person name is $ {this.firstName} and age is ${this.age} ");
//     }
// }
// person.about(); // call



function personInfo(){
    console.log(`person name is ${this.firstName} and age is ${this.age}`);
}

const person1 = {
    firstName : "harsh",
    age: 8,
    about: personInfo
}
const person2 = {
    firstName : "mohit",
    age: 18,
    about: personInfo
}
const person3 = {
    firstName : "nitish",
    age: 17,
    about: personInfo
}

person1.about();
person2.about();
person3.about();





// window Object 

// window Object -> global Object

//     console.log(this);
// console.log(window);


// function myFunc(){
//     "use strict";
//     console.log(this);
// }
// myFunc();

// function myFunc(){
//     console.log("hello world");
// }
// myFunc();







// call , apply , bind methods

// const user1 = {
//     firstName : "harshit",
//     age: 8,   
//     about : function (){
//         console.log(this.firstName, this.age);
//     }
// }

// const  user2 = {
//     firstName : "mohit",
//     age: 9,
// }

// user1.about.call(user2) // mohit     9
// user1.about.call()     // undefined  undefined
// user1.about.call(user1) // harshit   8

// const user1 = {
//     firstName : "harshit",
//     age: 8,   
//     about : function (hobby,favMusician){
//         console.log(this.firstName, this.age,hobby,favMusician);
//     }
// }
// user1.about.call(user2,"guitar","mojart") // mohit 9 guitar mozart


// defining function outside object
function about(hobby, favMusician){
    console.log(this.firstName, this.age, hobby, favMusician);
}

const user1 = {
    firstName : "harshit",
    age: 8,   
    about : function (hobby,favMusician){
        console.log(this.firstName, this.age,hobby,favMusician);
    }
}

const  user2 = {
    firstName : "mohit",
    age: 9,
}

about.call(user1,"guitar","mojart")
about.call(user2,"guitar","mojart")


// apply
//array pass

about.apply(user1, ["guitar", "bach"]);

// bind
// function return
about.bind(user1, ["guitar", "bach"]); // nothing print

const func = about.bind(user2, "guitar", "bach");
func();






const user1 = {
    firstName : "harshit",
    age: 8,
    about: function(){
        console.log(this.firstName, this.age);
    }   
}

// don't do this mistake 

// user1.about();
const myFunc = user1.about.bind(user1);
myFunc()






// arrow functions 
// no this in arrow function
// this in arrow function( is  from surrounding ) window object

const user1 = {
    firstName : "harshit",
    age: 8,
    about: () => {
        console.log(this.firstName, this.age);
    }   
}

// user1.about(); // undefined undefined
user1.about(user1);




// short Syntax

// const user1 = {
//     firstName : "harshit",
//     age: 8,
//     about: function(){
//         console.log(this.firstName, this.age);
//     }   
// }

// const user1 = {
//     firstName : "harshit",
//     age: 8,
//     about(){
//         console.log(this.firstName, this.age); //about method
//     }   
// }


user1.about();






// create more than 100 users

//  const user = {
//  firstName : "harshit",  
//  lastName : "khandelwal",
//  email : "devkhandelwal2508@gmail.com",
//  age : 2,
//  address :" House number, Colony Pincode , state" ,
//  about : function(){
//     return `${this.firstName} is ${this.age} years old.`;
//     },
//      is18 :  function(){
//        return this.age >= 18;
//    }
// }
// const aboutUser = user.about();
// console.log(aboutUser);


// function (that function create object)
// 2.) add key value pair 
// 3.) object ko return krega 

function createUser(firstName, lastName, email, age, address){
    
    const user = {};
    user.firstName = firstName;     //2.) add key value pair in object
    user.lastName = lastName;
    user.email = email;
    user.age = age;
    user.address = address;

    user.about = function(){
        return `${this.firstName} is ${this.age} years old.`;
    };
    user.is18 =  function(){
        return this.age >= 18;
    }
    return user;
}

const user1 = createUser('harshit', 'vashsith', 'harshit@gmail.com', 19, "my address");
console.log(user1);
const is18 = user1.is18();
const about = user1.about();
console.log(about);






// store methods in different objects


// when user 1 forms -> object create ->2 methods
// when user 2 forms -> object create ->2 methods
//                     .
//                     .
//                     .
//                     .
//when user 10k forms->object create -> 2 methods   
//      that many times memory fills




// function createUser(firstName, lastName, email, age, address){ 
//     const user = {};
//     user.firstName = firstName;     //2.) add key value pair in object
//     user.lastName = lastName;
//     user.email = email;
//     user.age = age;
//     user.address = address;

//     user.about = function(){
//         return `${this.firstName} is ${this.age} years old.`;
//     };
//     user.is18 =  function(){
//         return this.age >= 18;
//     }
//     return user;
// }



const userMethods = {
    about : function(){
        return `${this.firstName} is ${this.age} years old.`;
    },
    is18 : function(){
        return this.age >= 18;
    }
}
function createUser(firstName, lastName, email, age, address){
    const user = {};
    user.firstName = firstName;
    user.lastName = lastName;
    user.email = email;
    user.age = age;
    user.address = address;
    user.about = userMethods.about; //refrence(address)
    user.is18 = userMethods.is18; //refrence(address)
    return user;
}

const user1 = createUser('harshit', 'vashsith', 'harshit@gmail.com', 9, "my address");
const user2 = createUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = createUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");
console.log(user1.about());
console.log(user3.about());






const userMethods = {
    about : function(){
        return `${this.firstName} is ${this.age} years old.`;
    },
    is18 : function(){
        return this.age >= 18;
    },
    sing: function(){
        return 'toon na na na la la ';
    }
}
function createUser(firstName, lastName, email, age, address){
    const user = Object.create(userMethods);// {}  // proto is the refrence of user methods
    user.firstName = firstName;
    user.lastName = lastName;
    user.email = email;
    user.age = age;
    user.address = address;
    return user;
}

const user1 = createUser('harshit', 'vashsith', 'harshit@gmail.com', 9, "my address");
const user2 = createUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = createUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");
console.log(user1);
console.log(user1.about());
// console.log(user3.sing());






const obj1 = {
    key1: "value1",
    key2: "value2"
}
// const obj2 = {
//     key3: "value3", 
// }

// // another way :-
// const obj2 = {}
// obj2.key3= "value3";

// console.log(obj1.key1) // value 1
// console.log(obj2.key3) // value 3
// console.log(obj2.key1) // undefined


// what we want :- if js dose not find key1 on obj2 then it automatically go to obj1 and print key 1


// __proto__

// offical ecmascript documentation 

// [[prototype]]

// __proto__ , [[prototype]] => same
// prototype => different from previous two


// prototype  and __proto__ are different  


const obj2 = Object.create(obj1); // {}
// there is one more way to create empty object

obj2.key3 = "value3";
// obj2.key2 = "unique";
console.log(obj2);

console.log(obj2.__proto__); // Dunder




//prototype

function hello(){
    console.log("hello world");
}

// javascript function ===> function  + object

// console.log(hello.name);

// you can add your own properties 
// hello.myOwnProperty = "very unique value";
// console.log(hello.myOwnProperty);

// name property ---> tells function name;

// function provides more usefull properties.
// function provides (empty object {}) => prototype .


// console.log(hello.prototype); // {}

// only functions provide prototype property

hello.prototype.abc = "abc";
hello.prototype.xyz = "xyz";
hello.prototype.sing = function(){
    return "lalalla";
};
console.log(hello.prototype);
console.log(hello.prototype.sing());





// Use prototype

// const userMethods = {
//     about : function(){
//         return `${this.firstName} is ${this.age} years old.`;
//     },
//     is18 : function(){
//         return this.age >= 18;
//     },
//     sing: function(){
//         return 'toon na na na la la ';
//     }
// }

function createUser(firstName, lastName, email, age, address){
    const user = Object.create(createUser.prototype);// {}
    user.firstName = firstName;
    user.lastName = lastName;
    user.email = email;
    user.age = age;
    user.address = address;
    return user;
}
console.log(createUser.prototype); // we get prototype property or not    (yes)

createUser.prototype.about = function(){
    return `${this.firstName} is ${this.age} years old.`;
};
createUser.prototype.is18 = function (){
    return this.age >= 18; 
}
createUser.prototype.sing = function (){
    return "la la la la ";
}


const user1 = createUser('harshit', 'vashsith', 'harshit@gmail.com', 18, "my address");
const user2 = createUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = createUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");
console.log(user1);
console.log(user1.is18());





// new keyword

// 1.) empty object create -> value-> this = {}
// 2.)  return empty object ->value -> this {} 
// 3.) object.create(createUser.prototype); ->this keyword directly

// __proto__ (firefox) 
// // official ecmascript document
// [[prototype]]

// constructor function
 
function CreateUser(firstName, lastName, email, age, address){
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.age = age;
    this.address = address;
}
CreateUser.prototype.about = function(){
    return `${this.firstName} is ${this.age} years old.`;
};
CreateUser.prototype.is18 = function (){
    return this.age >= 18; 
}
CreateUser.prototype.sing = function (){
    return "la la la la ";
}


const user1 = new CreateUser('harshit', 'vashsith', 'harshit@gmail.com', 18, "my address");
const user2 = new CreateUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = new CreateUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");
console.log(user1);
console.log(user1.is18());




//has own property 

function CreateUser(firstName, lastName, email, age, address){
    this.firstName = firstName;
    this.lastName = lastName;
    this.email = email;
    this.age = age;
    this.address = address;
}
CreateUser.prototype.about = function(){
    return `${this.firstName} is ${this.age} years old.`;
};
CreateUser.prototype.is18 = function (){
    return this.age >= 18; 
}
CreateUser.prototype.sing = function (){
    return "la la la la ";
}


const user1 = new CreateUser('harshit', 'vashsith', 'harshit@gmail.com', 18, "my address");
const user2 = new CreateUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = new CreateUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");

for (let key in user1){
    // console.log(key)
    if(user1.hasOwnProperty(key)){
        console.log(key);
    }
   


}




// more about prototype

// let numbers =[1,2,3];
let numbers =[1,2,3];
console.log(Array.prototype);
console.log(numbers);
console.log(Object.getPrototypeOf(numbers));

// numbers.   --> many methods

//** javascript get these methods from prototype
//** prototype -> only functions --> eg:constructor functions
//** internally javascript array create
//** in javascript arrays are objects


function hello(){
    console.log("hello");
}
// by default we get prototype 
console.log(hello.prototype);
hello.prototype =  [] // change prototype
console.log(hello.prototype);
hello.prototype.push('1');
console.log(hello.prototype);




// 2015 / es6 

// class keyword 
// class are fake

class CreateUser{
    constructor(firstName, lastName, email, age, address){
       console.log("constructor called");
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
        this.age = age;
        this.address = address;
    }

    about(){
        return `${this.firstName} is ${this.age} years old.`;
    }
    is18(){
        return this.age >= 18;
    }
    sing(){
        return "la la la la ";
    }
func(a) // we can write parameter in methods
{
    console.log(a);
}
}

// class constructor can not be called without new keyword
const user1 = new CreateUser('harshit', 'vashsith', 'harshit@gmail.com', 18, "my address");
const user2 = new CreateUser('harsh', 'vashsith', 'harshit@gmail.com', 19, "my address");
const user3 = new CreateUser('mohit', 'vashsitha', 'harshit@gmail.com', 17, "my address");

console.log(user1.sing())
console.log(user1.is18())
console.log(user1.firstName())
console.log(user3.firstName())

console.log(Object.getPrototypeOf(user1));

user1.func("dev")





// class practice and extends keyword

class Animal {
    constructor(name, age){
        this.name = name;
        this.age = age;
    }

    eat(){
        return `${this.name} is eating`;
    }

    isSuperCute(){
        return this.age <= 1;
    }

    isCute(){
        return true;
    }
}

class Dog extends Animal // subclass
{

} 

// const animal1 = new Animal("tommy", 3);
// console.log(animal1);
// console.log(animal1.eat())
// console.log(animal1.isCute());

const tommy = new Dog("tommy", 3);
console.log(tommy);
console.log(tommy.isCute());



// super keyword

class Animal {
    constructor(name, age){
        this.name = name;
        this.age = age;
    }

    eat(){
        return `${this.name} is eating`;
    }

    isSuperCute(){
        return this.age <= 1;
    }

    isCute(){
        return true;
    }
}

class Dog extends Animal{
    constructor(name, age, speed){
        super(name,age);
        this.speed = speed;
    }

    run(){
        return `${this.name} is running at ${this.speed}kmph`
    }
} 
// object / instance  (same)
const tommy = new Dog("tommy", 3,45);
console.log(tommy.run());




// same method in subclass

// first sub class method called then super class 

class Animal {
    constructor(name, age){
        this.name = name;
        this.age = age;
    }

    eat(){
        return `${this.name} is eating`;
    }

    isSuperCute(){
        return this.age <= 1;
    }

    isCute(){
        return true;
    }
}

class Dog extends Animal{
    constructor(name, age, speed){
        super(name,age);
        this.speed = speed;
    }

    eat(){
        return `Modified Eat : ${this.name} is eating`
    }

    run(){
        return `${this.name} is running at ${this.speed}kmph`
    }
} 
// object / instance 
// const tommy = new Dog("tommy", 3,45);
// console.log(tommy.run());
// console.log(tommy.eat());

const animal1 = new Animal('sheru', 2);
console.log(animal1.eat());





// getter and setters 

class Person{
    constructor(firstName, lastName, age){
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    get fullName(){
        return `${this.firstName} ${this.lastName}`
    }
    set fullName(fullName)
      // fullName.split(" ")
      // [devansh, khandelwal]
    { //   destructure
        const [firstName, lastName] = fullName.split(" ");
        this.firstName = firstName;
        this.lastName = lastName;
    }
}


const person1 = new Person("harshit", "sharma", 5);
// console.log(person1.fullName());

console.log(person1.fullName); // use as property
person1.fullName = "Devansh Khandelwal";
console.log(person1);
// console.log(person1.fullName);







// static methods and properties

class Person{
    constructor(firstName, lastName, age){
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    // methods which are directly related to claa
    static classInfo(){
        return 'this is person class';
    }
    static desc = "static property";
    get fullName(){
        return `${this.firstName} ${this.lastName}`
    }
    set fullName(fullName){
        const [firstName, lastName] = fullName.split(" ");
        this.firstName = firstName;
        this.lastName = lastName;
    }
    eat(){
        return `${this.firstName} is eating`;
    }

    isSuperCute(){
        return this.age <= 1;
    }

    isCute(){
        return true;
    }
}

const person1 = new Person("harshit", "sharma", 8);
// // console.log(person1.eat());
// person1.classInfo(); // error of not a function
// direct call
const info = Person.classInfo();
console.log(Person.desc);
console.log(info);






// complication
// code execution

// How java script code executes ?
// why complication ?
// what is global execution context ?
// what is local execution context ?


// ** 1) Compile / Compilation phase

// (***according to ecmascript--> *early error checking, *determing apporipate scope for variables --> for that parsing  is necessary )

// Compilation has 3 phases -:
// a) Tocanizing / Lexing - Tokenization is the process of exchanging sensitive data for nonsensitive data called “tokens” that can be used in a database or internal system without bringing it into scope. (****code broke into small chuncks called tokens)

// Lexing and tokenizing terms are used interchangeably, but there is a subtle difference between them. Lexing is a process of tokenization but it also checks if it needs to be considered as a distinct token. We can consider Lexing to be a smart version of tokenization.


// b) Parsing- Parsing means analyzing and converting a program into an internal format that a runtime environment can actually run.(***** Tokens understand --> Abstact syntax tree create)


// c) Code generation -  In computing, code generation is part of the process chain of a compiler and converts intermediate representation of source code into a form (e.g., machine code) that can be readily executed by the target system.


// ** 2) Code Execution Phase :-
// (in J.S. code executes inside execution context(code execute karne ke liye execution context create karna hogaa)  --> 

// first, Global execution context creates ==> 2 phases create...


// a) Global memory (Creation phase)


// (**ecma script -> When control enters an execution context, the scope chain is created and initialized, variable instanination is performed, and the 'this' value is determined)


// Global code--> this--> Global Object(window) 
//Eval code--> this--> ->this in calling context
 
//  hoisting (****storing in memory before execution of code)


// firstName : undefined  (in case of var)

// this(value): browser --> == window // --> window (already present) is a  object provided by browser .

//**** javascript is synchronous programming language(Synchronous programming is a programming model where operations take place sequentially. ) (Asynchronous feature was provided by browser)  and single threaded 

//B) Code Execution Phase :-
// Synchronous programming is a programming model where operations take place sequentially.

// Global execuition context (GEC) -> added in stack

//  Global Execution Context creates => 2 Phases create => 
// 1)  Creation Phase /Global Memory /Environment record / Environment variable (when control enters in  Global Execution Context variables created in global memory)  

// 2) Code Execution Phase

// 1) console.log(this); // {window}
// 2) console.log(window); // {window}
// 3) console.log(firstname); // undefined
// 4) var firstName = "dev"
// 5) console.log(firstName);  //dev 
//// **** Global execuition context (GEC) -> pop out of stack

console.log(this);
console.log(window);
console.log(firstName);
var firstName = "dev";
console.log(firstName);











//  hoisting (****storing in memory before execution of code)


console.log(this);
console.log(window);
console.log(myFunction);

console.log(fullName);

function myFunction(){
    console.log("this is my function");
}

var firstName = "Harshit";
var lastName = "Sharma"
var fullName = firstName + " " + lastName;
console.log(fullName);

// compilation phase:-
// global scope:-
// firstName,lastName,fullName,myFunction

// lexing-->javascript -> lexical scope language-> code kaha likha vaha ka scope
//eg)  lexcically my function is in global scope

// code execution phase :-

// // ****
// Global execuition context (GEC) -> added in stack


//  Global execuition context (GEC) ==> creation in 2 phases

// 1) Creation phase(Global memory)

// present before creation of global execution context
// window object provided by browser

//** window object -> {} 
//**console.log(this) -> window
//**var firstName = "Harshit" -> undefined
//**var lastName = "Sharma" -> undefined
//**var fullName = firstName + " " + lastName -> undefined
//**function( keyword) -> myFunction  ->added in global memory

// execution starts :--
//2) Code execution phase

// console ;- 
//1 console.log(this); -> {w}
//2 console.log(window);->{w}
//3 console.log(myFunction); -> "print" -> f myFunction(){
//     console.log("this is my function");
// }

//4 console.log(fullName); ->undefined

//5 function myFunction() ->   nothing hapens as my function is alredy present in global memory
// {               
//     console.log("this is my function");
// }

//6  var firstName = "Harshit"; =>global memory (undefined -> harshit)
//7 var lastName = "Sharma" =>global memory (undefined ->  sharma)
//8 var fullName = firstName + " " + lastName; =>global memory (undefined-> harshit sharma )
//9 console.log(fullName);->harshit sharma

//// **** Global execuition context (GEC) -> pop out of stack






console.log(myFunction);

// function expression
var myFunction = function(){
    console.log("this is my function");
}

console.log(myFunction);

//1) compilation
// global scope ->my function

// global execution context -> added in stack
// global execution context -> 2phases=> 1) creation phase (global memory) 2) code execution phase

// global memory -> 
// window object -> provided by browser 
// this(value) ->-> refrence-> {window}

// function expression 
// myFunction treated as a variable -> undefined(var)

//  Code execution phase (CEP) :-

//console.log(myFunction); -> Undefined
// var myFunction = function()  => ( assign function in myfunction in global memory)
// {
//     console.log("this is my function");
// }

// console.log(myFunction); -> function print ->
// f() {
//     console.log("this is my function");
// }

//// **** Global execuition context (GEC) -> pop out of stack







// console.log(firstName);
// console.log(typeof firstName);
let firstName = "Harshit";
console.log(firstName);

// (A) Compilation Phase
// (B) Code Execution Phase

// Global execuition context (GEC) -> added in stack

//  Global Execution Context creates => 2 Phases create => 
// 1)  Creation Phase /Global Memory /Environment record / Environment variable (when control enters in  Global Execution Context variables created in global memory)  
 
// Global Memory -->
// window object -> provided by browser 
// this(value) => refrence-> {window}
// firstName => uninitialised (let / const case)

// 2) Code Execution Phase


//1) console.log(firstName); => uninitialised => error (let / const case)

// Uncaught ReferenceError:
// Cannot access 'firstName' before initialization

// (hosting occurs in case of let and const but they are uninitialized)


// console.log(firstName); (only this line is written)

// Uncaught ReferenceError:  (this error comes when variable is not present)
// firstName is not defined


// firstName is present in "temporal dead zone" till it is uninitialized


// let firstName;  => print => undefined 
// const firstName;  => print => error =>Uncaught SyntaxError:

// (**
// console.log(typeof firstName); => print => error => Uncaught ReferenceError: Cannot access 'firstName' before initialization
// let firstName = "harshit";
// )

// (**
// console.log(typeof firstName); => print => Undefined 
// )




console.log("hello world");
let firstName = "Harshit";
let lastName = "Vashistha";

const myFunction = function() {
    let var1 = "First Variable";
    let var2 = "second Variable";
    console.log(var1);
    console.log(var2);
}
// compilation -
// early error checking (no error)
// Global Scope (lastName,firstName,myFunction(var1,var2))

//code execution phase -
// Global execution context
// memory creation phase......




// function execution context 

let foo = "foo";
console.log(foo);
function getFullName(firstName, lastName){
    console.log(arguments);
    let myVar = "var inside func";
    console.log(myVar);
    const fullName = firstName + " " + lastName;
    return fullName;
}

const personName = getFullName("harshit", "sharma");
console.log(personName);